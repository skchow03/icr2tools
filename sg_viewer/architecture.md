# SG Viewer Architecture

The SG Viewer is a Qt-based desktop utility for inspecting SG track files. It is organized around a single-window UI with a controller that coordinates preview rendering, section selection, and supporting dialogs. The main concepts and data flow are summarized below.

## Entry Points and Application Shell
- `sg_viewer/main.py` bootstraps logging, instantiates the Qt application, and shows the main window before running the event loop. Cleanup is attached to the Qt `aboutToQuit` signal for best-effort shutdown. Pass `--debug` or `--log-level DEBUG` to increase verbosity, and `--log-file` or the `SG_VIEWER_LOG_PATH` environment variable to control the log destination.【F:sg_viewer/main.py†L1-L42】
- `sg_viewer/app.py` defines the `SGViewerApp` (`QApplication`) and `SGViewerWindow` (`QMainWindow`). The window assembles the preview canvas, elevation profile, navigation controls, and sidebar labels, then constructs the controller to wire behaviors.【F:sg_viewer/app.py†L1-L102】

## Controller and UI Coordination
- `SGViewerController` owns menu actions, buttons, and dialog management. It centralizes file loading, keeps the section and heading tables in sync with the preview, and triggers elevation profile refreshes when selections or cross-section choices change.【F:sg_viewer/viewer_controller.py†L1-L113】【F:sg_viewer/viewer_controller.py†L119-L169】
- File opening goes through `_open_file_dialog`, which forwards the chosen path to `load_sg`. Successful loads enable table buttons, populate cross-section options, and refresh the elevation profile view.【F:sg_viewer/viewer_controller.py†L71-L118】

## Preview Rendering Flow
- The `SGPreviewWidget` is a custom `QWidget` that tracks loaded SG/TRK data, sampled centerline geometry, selection state, and current transform (pan/zoom). It handles painting via `rendering_service.paint_preview`, mouse wheel zoom, and click-based section selection using `SelectionManager`. Clearing or loading a file resets internal state and selection context.【F:sg_viewer/preview_widget.py†L14-L121】【F:sg_viewer/preview_widget.py†L141-L214】
- Transform management (fit-to-view scaling, clamping, and coordinate mapping) is delegated to helpers in `preview_state`, while curve highlighting and start/finish markers are drawn by `rendering_service` based on the widget’s cached geometry and selection info.【F:sg_viewer/preview_widget.py†L100-L121】【F:sg_viewer/preview_widget.py†L168-L214】
- The `SelectionManager` converts click locations into centerline distances, resolves the corresponding section, and emits `selectionChanged` events consumed by the main window to update sidebar labels and the elevation profile selection range.【F:sg_viewer/selection.py†L1-L112】

## Data Loading and Modeling
- `preview_loader_service.load_preview` acts as a thin façade over `preview_loader.load_preview`, keeping the controller decoupled from the loader implementation.【F:sg_viewer/preview_loader_service.py†L1-L9】
- `preview_loader.load_preview` parses the SG/TRK file pair, samples the reconstructed centerline, builds a spatial index, and derives start/finish normals. It also constructs `SectionPreview` records for each section, including geometry polylines and optional curve metadata. The result is packaged into `PreviewData`, which the preview widget consumes directly.【F:sg_viewer/preview_loader.py†L1-L63】【F:sg_viewer/preview_loader.py†L66-L115】
- Section and preview data structures live in `sg_model.py`, providing immutable `dataclass` definitions for `SectionPreview` and `PreviewData`. These types carry the geometry, headings, and metadata passed among the loader, controller, and renderer.【F:sg_viewer/sg_model.py†L1-L34】

## Supporting Dialogs and Profiles
- Section and heading tables are provided by `SectionTableWindow` and `HeadingTableWindow`; the controller lazily instantiates and updates them from the preview widget’s current section set and heading vectors.【F:sg_viewer/viewer_controller.py†L29-L113】【F:sg_viewer/viewer_controller.py†L131-L158】
- Elevation profile rendering is managed by `ElevationProfileWidget`, which is fed by `build_elevation_profile` results generated by the preview widget for the currently selected cross-section index.【F:sg_viewer/app.py†L22-L69】【F:sg_viewer/viewer_controller.py†L160-L169】

## Typical Workflow
1. User launches the app via `python -m sg_viewer.main` or equivalent; logging initializes and the window is displayed.【F:sg_viewer/main.py†L1-L37】
2. The user chooses **File → Open SG…**. The controller loads the SG/TRK pair, populates preview geometry, and updates UI affordances (tables, cross-section dropdown, sidebar status).【F:sg_viewer/viewer_controller.py†L71-L118】【F:sg_viewer/preview_widget.py†L141-L183】
3. The preview widget draws the sampled centerline; users can pan/zoom, toggle curve markers, or click near the centerline to select sections. Selection updates highlight geometry, populate sidebar metadata, and constrain the elevation profile view.【F:sg_viewer/preview_widget.py†L168-L214】【F:sg_viewer/selection.py†L83-L112】【F:sg_viewer/app.py†L70-L102】
4. Optional dialogs (section or heading tables) and elevation profiles stay synchronized with the current preview data, using controller callbacks to propagate edits back into the in-memory section set.【F:sg_viewer/viewer_controller.py†L119-L158】
